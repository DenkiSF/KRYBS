// src/kuznechik/core.rs
use crate::kuznechik::block::{Block};
use crate::kuznechik::keys::{Keys};
use crate::kuznechik::operations::{BLOCK_SIZE, KEY_SIZE, x_transform_iv};
use crate::kuznechik::kdf::kdf_gostr3411_2012_256;

#[derive(Debug, Clone)]
pub struct Kuznechik {
    keys: Keys
}

impl Kuznechik {

    pub fn new(key: [u8; KEY_SIZE]) -> Self {
        Kuznechik {
            keys: Keys::new(key)
        }
    }

    pub fn new_from_kdf(kin: &[u8], label: &[u8], seed: &[u8]) -> Self {
        let key = kdf_gostr3411_2012_256(kin, label, seed);
        Kuznechik::new(key)
    }

    pub fn encrypt_block(&self, block: &mut Block) -> [u8; BLOCK_SIZE] {
        // 9 раундов с преобразованиями X -> S -> L
        for round in 1..=9 {
            block.x(self.keys.get_round_key(round));
            block.s();
            block.l();
        }

        // 10-й раунд (только X-преобразование)
        block.x(self.keys.get_round_key(10));
        block.get_block()
    }

    pub fn decrypt_block(&self, block: &mut Block) -> [u8; BLOCK_SIZE] {

        // 10-й раунд в обратном порядке (только X)
        block.x(self.keys.get_round_key(10));

        // 9 раундов в обратном порядке: L⁻¹ -> S⁻¹ -> X
        for round in (1..=9).rev() {
            block.l_inv();
            block.s_inv();
            block.x(self.keys.get_round_key(round));
        }

        block.get_block()
    }

    fn padding(chunk: Vec<u8>) -> Block {
        let mut padded_block = [0u8; BLOCK_SIZE];
        let chunk_len = chunk.len();

        padded_block[..chunk_len].copy_from_slice(&chunk);
        padded_block[chunk_len] = 0x80;
        
        Block::new(padded_block)
    }

    fn unpadding(block: Block) -> Vec<u8> {
        let data = block.get_block();
        for (i, &byte) in data.iter().enumerate().rev() {
            if byte == 0x80 {
                return  data[..i].to_vec()
            }

            if byte != 0x00 {
                return data.to_vec()
            }
        }

        Vec::new()
    }

    pub fn encrypt_cbc(&self, plaintext: Vec<u8>, iv: Vec<u8>) -> Vec<Block> {
        assert_eq!(iv.len() % BLOCK_SIZE, 0, "IV length must be multiple of block size");
        // 1. Create block chunks and pad last block
        let mut plaintext_chunks = Vec::new();
        let mut cipher_chunks: Vec<Block> = Vec::new();
        for chunk in plaintext.chunks(BLOCK_SIZE){
            if chunk.len() < BLOCK_SIZE {
                plaintext_chunks.push(Self::padding(Vec::from(chunk)))
            }
            else {
                plaintext_chunks.push(Block::new(chunk.try_into().unwrap()));
            }
        }
        
        // 2. Init reg_r (из ГОСТ, R1 = IV)
        let mut reg_r = iv.to_vec();
        let m = reg_r.len();
        
        // 4. Encrypt every block
        for chunk in plaintext_chunks {
            let msb = &reg_r[..BLOCK_SIZE];
            
            // Block work
            let encrypted_block = self.encrypt_block(&mut Block::new(x_transform_iv(chunk.get_block(),msb)));
            
            // Update r
            reg_r.copy_within(BLOCK_SIZE.., 0);
            reg_r[m - BLOCK_SIZE..].copy_from_slice(&encrypted_block);

            // Save block
            cipher_chunks.push(Block::new(encrypted_block));
        }
        
        cipher_chunks
    }

    pub fn decrypt_cbc(&self, ciphertext: Vec<u8>, iv: Vec<u8>) -> Vec<Vec<u8>> {
        // 1. Create block chunks
        let mut plaintext_chunks: Vec<Vec<u8>> = Vec::new();
        let mut cipher_chunks: Vec<Block> = Vec::new();
        for block in ciphertext.chunks(BLOCK_SIZE) {
            cipher_chunks.push(Block::new(block.try_into().unwrap()));

        }

        // 2. Reg_r init
        let mut reg_r = iv.to_vec();
        let m = reg_r.len();
        
        // 3. Decrypt chunk
        for (i, chunk) in cipher_chunks.iter().enumerate() {
            let cipher_chunk = chunk.get_block().clone();
            let msb = &reg_r[..BLOCK_SIZE];
            let decrypted_block = x_transform_iv(self.decrypt_block(&mut Block::new(cipher_chunk)),msb);
            if i+1 == cipher_chunks.len() {
                plaintext_chunks.push(Self::unpadding(Block::new(decrypted_block)));
            }
            else {
                plaintext_chunks.push(decrypted_block.to_vec());
            }

            reg_r.copy_within(BLOCK_SIZE.., 0);
            reg_r[m - BLOCK_SIZE..].copy_from_slice(&cipher_chunk);
        }

        plaintext_chunks
    }
}



#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cbc_enc_test() {
        let kuznechik = Kuznechik::new( [0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);
        let iv = Vec::from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xce, 0xf0, 0xa1, 0xb2, 0xc3, 0xd4, 0xe5, 0xf0, 0x01, 0x12,
        0x23, 0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x90, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19]);
        let plaintext = Vec::from([0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00, 0x11]);
        let ciphertext: Vec<u8>  = Vec::from([0x68, 0x99, 0x72, 0xd4, 0xa0, 0x85, 0xfa, 0x4d, 0x90, 0xe5, 0x2e, 0x3d, 0x6d, 0x7d, 0xcc, 0x27, 0x28, 0x26, 0xe6, 0x61, 0xb4, 0x78, 0xec, 0xa6, 0xaf, 0x1e, 0x8e, 0x44, 0x8d, 0x5e, 0xa5, 0xac, 0xfe, 0x7b, 0xab, 0xf1, 0xe9, 0x19, 0x99, 0xe8, 0x56, 0x40, 0xe8, 0xb0, 0xf4, 0x9d, 0x90, 0xd0, 0x16, 0x76, 0x88, 0x06, 0x5a, 0x89, 0x5c, 0x63, 0x1a, 0x2d, 0x9a, 0x15, 0x60, 0xb6, 0x39, 0x70]);
        for (i, block) in kuznechik.encrypt_cbc(plaintext, iv).iter().enumerate() {
            assert_eq!(block.get_block(), ciphertext[BLOCK_SIZE*i..BLOCK_SIZE*(i+1)])
        }
    }

    #[test]
    fn cbc_dec_test() {
        let kuznechik = Kuznechik::new( [0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);
        let iv = Vec::from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xce, 0xf0, 0xa1, 0xb2, 0xc3, 0xd4, 0xe5, 0xf0, 0x01, 0x12,
        0x23, 0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x90, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19]);
        let plaintext: Vec<u8> = Vec::from([0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00, 0x11]);
        let ciphertext: Vec<u8>  = Vec::from([0x68, 0x99, 0x72, 0xd4, 0xa0, 0x85, 0xfa, 0x4d, 0x90, 0xe5, 0x2e, 0x3d, 0x6d, 0x7d, 0xcc, 0x27, 0x28, 0x26, 0xe6, 0x61, 0xb4, 0x78, 0xec, 0xa6, 0xaf, 0x1e, 0x8e, 0x44, 0x8d, 0x5e, 0xa5, 0xac, 0xfe, 0x7b, 0xab, 0xf1, 0xe9, 0x19, 0x99, 0xe8, 0x56, 0x40, 0xe8, 0xb0, 0xf4, 0x9d, 0x90, 0xd0, 0x16, 0x76, 0x88, 0x06, 0x5a, 0x89, 0x5c, 0x63, 0x1a, 0x2d, 0x9a, 0x15, 0x60, 0xb6, 0x39, 0x70]);
        for (i, block) in kuznechik.decrypt_cbc(ciphertext,iv).iter().enumerate() {
            assert_eq!(*block,plaintext[BLOCK_SIZE*i..BLOCK_SIZE*(i+1)])
        }
    }

    #[test]
    fn encrypt_block_test() {
        let kuznechik = Kuznechik::new( [0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);
        let mut plaintext = Block::new([ 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88 ]);
        let ciphertext = [0x7f, 0x67, 0x9d, 0x90, 0xbe, 0xbc, 0x24, 0x30, 0x5a, 0x46, 0x8d, 0x42, 0xb9, 0xd4, 0xed, 0xcd];
        assert_eq!(kuznechik.encrypt_block(&mut plaintext), ciphertext)
    }

    #[test]
    fn decrypt_block_test() {
        let kuznechik = Kuznechik::new( [0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);
        let plaintext = [ 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88 ];
        let mut ciphertext = Block::new([0x7f, 0x67, 0x9d, 0x90, 0xbe, 0xbc, 0x24, 0x30, 0x5a, 0x46, 0x8d, 0x42, 0xb9, 0xd4, 0xed, 0xcd]);
        assert_eq!(kuznechik.decrypt_block(&mut ciphertext), plaintext)
    }
}